# Quick Start
# DevTools Project
[![My Java CI](https://github.com/reallyloud/devtools/actions/workflows/ci.yml/badge.svg)](https://github.com/reallyloud/devtools/actions/workflows/ci.yml)
### Чтобы запустить задачи необходимо дважды нажать run, build или test через Gradle tool Window или Run Anything (ctrl + ctrl)
# Packages
### Пакет ru.mentee.power нужен для порядка в проекте и правильной видимости классов
# Variables Table 
| Тип     | Имя переменной/метода |
| ------- | --------------------- |
| String  | menteeName            |
| int     | sprintNumber          |
| int     | plannedHoursPerWeek   |
| boolean | readyForSprint()    |
### Ссылка на урок
https://mentee-power.xl.ru/learn/MCIneBj4KkyH-GIRCspFvA/tasks

## Сценарий ручной проверки DVT-7

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До:    import java.util.List; import java.util.ArrayList; import java.io.File;
После: import java.io.File; import java.util.ArrayList; import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

## Code Review Checklist

Используйте этот чеклист для само-ревью перед запросом ревью у ментора:

### Функциональность
- [ ] Код решает поставленную задачу полностью
- [ ] Обработаны граничные случаи (null, пустые данные, экстремальные значения)
- [ ] Обработка ошибок реализована корректно

### Тесты
- [ ] Добавлены тесты для нового функционала (или обновлены существующие)
- [ ] Все тесты проходят локально: `./gradlew test`
- [ ] Покрыты позитивные и негативные сценарии
- [ ] JaCoCo coverage ≥ 80% для нового кода

### Читаемость и стиль
- [ ] Имена переменных, методов и классов отражают назначение
- [ ] Нет дублирования кода (DRY principle)
- [ ] Checkstyle проходит без ошибок: `./gradlew checkstyleMain`
- [ ] Нет закомментированного кода или отладочного вывода (`System.out.println`)

### Документация
- [ ] README обновлён (если добавлена новая функциональность)
- [ ] Публичные методы имеют JavaDoc (если применимо)
- [ ] Примеры использования актуальны
- [ ] Runbook обновлён (если изменились команды запуска/проверки)

### Производительность и безопасность
- [ ] Нет очевидных проблем производительности
- [ ] Нет хардкода паролей, токенов или конфиденциальных данных

## Примеры Code Review комментариев

### Хорошие комментарии (конструктивные)

**Пример 1:**

**Проблема:** Метод `calculateDiscount` (строка 45) имеет 3 вложенных if-else и 40 строк.
**Почему это важно:** Сложная логика плохо тестируется и тяжело поддерживается.
**Предложение:** Вынести каждое условие в отдельный метод (например, `isEligibleForBonusDiscount()`)
и использовать паттерн Strategy для разных типов скидок.



**Пример 2:**

**Проблема:** Тест `testProcessOrder` (строка 78) проверяет только успешный сценарий.
**Почему это важно:** Не проверена обработка ошибок при недостаточном балансе.
**Предложение:** Добавить тест `testProcessOrder_InsufficientBalance_ThrowsException()`
с использованием `assertThatThrownBy()`.



### Плохие комментарии (неконструктивные)

**Пример 1:**

Этот код ужасен, полностью переписать.


**Почему плохо:** Нет конкретики (что именно плохо), нет предложения (как исправить),
токсичный тон (демотивирует автора).

**Пример 2:**

Здесь лучше использовать Stream API.


**Почему плохо:** Нет объяснения почему лучше, нет примера как переписать,
неясно какую проблему это решает.

---
## Личный глоссарий терминов Dev Tools

### Java-экосистема

#### JDK — Java Development Kit

**Определение:** Комплект разработчика Java — набор инструментов для создания, компиляции и отладки Java-приложений. Включает компилятор (javac), инструменты для упаковки (jar), генерации документации (javadoc) и саму JRE для запуска.

**Контекст использования:** Необходим на компьютере разработчика для превращения исходного кода (_.java_) в байт-код (_.class_) и сборки проекта. Без JDK невозможна разработка на Java.

**Пример:** После установки выполняем `java -version` для проверки версии. В IntelliJ IDEA настраиваем Project SDK: **File → Project Structure → Project → SDK** → выбираем путь к установленному JDK.

**Источник:** [https://docs.oracle.com/en/java/javase/21/](https://docs.oracle.com/en/java/javase/21/)


#### JRE — Java Runtime Environment

**Определение:** Среду выполнения Java — минимальная реализация виртуальной машины для запуска уже скомпилированных Java-приложений. Включает JVM и базовые библиотеки классов, но не содержит компилятор и инструменты разработки.

**Контекст использования:** Устанавливается на компьютеры конечных пользователей или серверы, где требуется только запуск готовых Java-программ (например, веб-приложений, десктопных программ).

**Пример:** Запуск нашей программы devtools.

**Источник:** [https://docs.oracle.com/en/java/javase/21/](https://docs.oracle.com/en/java/javase/21/)


#### JVM — Java Virtual Machine

**Определение:** Виртуальная машина Java — абстрактная вычислительная машина, которая исполняет байт-код Java. Обеспечивает ключевые возможности платформы: переносимость (write once, run anywhere), управление памятью (сборка мусора), безопасность.

**Контекст использования:** Является сердцем как JRE, так и JDK. Загружает файлы `.class`, проверяет байт-код, интерпретирует его или компилирует в машинный код (Just-In-Time компиляция) и выполняет. Разные вендоры (Oracle, OpenJDK, Azul) предлагают свои реализации JVM.

**Пример:** Любая активность с java программой.

**Источник:** [https://docs.oracle.com/javase/specs/jvms/se21/html/](https://docs.oracle.com/javase/specs/jvms/se21/html/)


#### Gradle Wrapper - Упаковщик Gradle

**Определение:** Обёртка Gradle — скрипт (gradlew или gradlew.bat) и небольшой JAR-файл, которые позволяют выполнять сборку проекта с помощью заранее заданной версии Gradle, не требуя его предварительной установки в системе.

**Контекст использования:** Используется в проектах для обеспечения консистентности сборок на разных машинах (у разработчиков, на CI-сервере). Гарантирует, что все используют одинаковую версию Gradle и её настроек.

**Пример:** ./gradlew run запускает Gradle Wrapper в проекте devtools

**Источник:** [https://docs.gradle.org/current/userguide/gradle_wrapper.html](https://docs.gradle.org/current/userguide/gradle_wrapper.html)


#### Build Tool - Инструмент сборки

**Определение:** Инструмент сборки — программа, которая автоматизирует процессы компиляции исходного кода, управления зависимостями, запуска тестов, упаковки артефактов и развертывания.

**Контекст использования:** Ключевой инструмент в жизненном цикле любого проекта. Позволяет стандартизировать и автоматизировать сборку, избавляя разработчика от ручных скриптов. В Java-экосистеме основными являются **Maven**, **Gradle** и **Ant**.

**Пример:** ./gradlew build

**Источник (Gradle):** [https://docs.gradle.org](https://docs.gradle.org/) | **Источник (Maven):** [https://maven.apache.org/guides/](https://maven.apache.org/guides/)


#### Dependency

**Определение:** Зависимость — внешняя библиотека или модуль, который требуется проекту для компиляции, тестирования или выполнения. Зависимости декларативно описываются в конфигурационном файле инструмента сборки.

**Контекст использования:** Используется для подключения стороннего функционала без написания кода "с нуля", например, библиотек для работы с БД (Hibernate), веб-фреймворков (Spring), утилит (Apache Commons). Инструменты сборки (Maven/Gradle) автоматически скачивают их из репозиториев (Maven Central).

**Пример:** Поля dependencies в build.gradle

**Источник (Maven):** [https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)

#### Artifact - Артефакт

**Определение:** Артефакт — выходной продукт процесса сборки, готовый к использованию или развертыванию. В Java-мире это обычно JAR (Java ARchive), WAR (Web ARchive) или EAR (Enterprise ARchive) файлы.

**Контекст использования:**Результат работы инструмента сборки (Build Tool). Исполняемые артефакты разворачиваются на серверах или распространяются пользователям. Библиотеки (артефакты-зависимости) публикуются в репозитории для использования в других проектах.

**Пример:** JAR файлы! Например devtools-1.0-SNAPSHOT.jar

**Источник:**[https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html](https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html)


### Категория: Инструменты

#### IDE — Integrated Development Environment

**Определение:** Интегрированная среда разработки — мощное приложение, которое предоставляет разработчику комплекс средств для написания, отладки, тестирования и рефакторинга кода в рамках единого интерфейса.

**Контекст использования:** Основной рабочий инструмент разработчика. Повышает продуктивность за счёт автодополнения кода (code completion), навигации, встроенного отладчика, интеграции с системами контроля версий (Git) и инструментами сборки (Gradle/Maven).

**Пример:** IntelliJ IDEA,Visual Studio Code

**Источник (IntelliJ IDEA):** [https://www.jetbrains.com/idea/help/](https://www.jetbrains.com/idea/help/)


#### SDK — Software Development Kit

**Определение:** Комплект разработчика программного обеспечения — набор инструментов, библиотек, документации и примеров кода, предназначенный для создания приложений под конкретную платформу, фреймворк или технологию.

**Контекст использования:** Используется для разработки под определенную среду. Если JDK — это SDK для Java в целом, то Android SDK — для мобильной разработки под Android, а Cloud SDK (например, от AWS или Google) — для работы с облачными сервисами.

**Пример:** Для разработки Android-приложений на Java нужно установить **Android SDK**, который включает эмуляторы, инструменты для сборки APK и библиотеки Android API.

**Источник (Android SDK):** [https://developer.android.com/studio](https://developer.android.com/studio)


#### Git - Git

**Определение:** Распределённая система контроля версий (VCS), которая позволяет отслеживать изменения в исходном коде, координировать работу нескольких разработчиков и управлять версиями проекта.

**Контекст использования:** Фактический стандарт для контроля версий в современной разработке. Используется для фиксации истории изменений (коммитов), создания веток для новых функций, слияния кода и отката к предыдущим состояниям.

**Пример:** `git init` (инициализация репозитория), `git add .` (добавление изменений), `git commit -m "message"` (фиксация версии)

**Источник:** [https://git-scm.com/doc](https://git-scm.com/doc)

#### Repository - Репозиторий

**Определение:** Репозиторий — хранилище, содержащее все файлы проекта, историю их изменений (коммитов) и метаданные системы контроля версий (например, Git).

**Контекст использования:** Бывает **локальным** (папка `.git` на вашем компьютере) и **удалённым** (сервис-хостинг, такой как GitHub, GitLab или Bitbucket). Удалённый репозиторий служит центральной точкой синхронизации для команды и резервной копией кода.

**Пример:** Создание нового проекта на **GitHub** создаёт удалённый репозиторий. Клонируем его командой `git clone <url>`, получая локальную копию, в которой и ведём работу.

**Источник (GitHub):** [https://docs.github.com/en/repositories](https://docs.github.com/en/repositories)


#### Commit - Commit

**Определение:** Коммит — атомарная операция фиксации набора изменений в файлах проекта в истории репозитория Git. Каждый коммит имеет уникальный хэш, автора, дату и текстовое описание (commit message).

**Контекст использования:** Используется для сохранения "снимков" (snapshots) кода в определённый момент времени. Это позволяет отслеживать эволюцию проекта, понимать, кто и зачем внёс изменения, и при необходимости откатываться к стабильным состояниям.

**Пример:** Команда `git commit -m "Fix null pointer exception in UserService"` фиксирует все подготовленные изменения (`git add`) с  сообщением в кавычках.

**Источник (Git):** [https://git-scm.com/docs/git-commit](https://git-scm.com/docs/git-commit)



#### Branch - Ветка

**Определение:** Ветка — изолированная линия разработки в репозитории Git. Позволяет вести работу над новой функцией, экспериментировать или исправлять баги, не затрагивая основную стабильную версию кода (часто ветку `main` или `master`).

**Контекст использования:** Ключевой механизм для параллельной работы в команде. Каждая задача/фича/багфикс обычно выполняется в своей ветке. После завершения работы ветка сливается (merge) обратно в основную.

**Пример:** Создание ветки для новой функции: git checkout -b feature/DVT-8. Все коммиты по этой функции делаются внутри этой ветки, не влияя на `main.

**Источник (Git):** [https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell)


#### Pull Request (PR) / Merge Request (MR)

**Определение:** Запрос на слияние — механизм в платформах (GitHub, GitLab и др.), позволяющий разработчику предложить изменения из своей ветки для вливания в другую ветку (обычно `main`). Инициирует процесс обсуждения и проверки кода (code review).

**Контекст использования:** Основной инструмент для внесения изменений в командных проектах. PR — это не только запрос на слияние, но и место для обсуждения кода, запуска автоматических тестов (CI) и проверки стиля перед тем, как код попадёт в основную ветку.

**Пример:** Завершив работу в ветке `feature/DVT-12`, создаём PR в веб-интерфейсе GitHub, Code Review, а после их апрува и успешных проверок CI merge изменения в `main`.

**Источник (GitHub):** [https://docs.github.com/en/pull-requests](https://docs.github.com/en/pull-requests)


### Категория: Процессы

#### Code Review - Ревью кода

**Определение:** Код-ревью — процесс проверки исходного кода другими членами команды перед его слиянием в основную ветку. Цель — улучшение качества кода, поиск ошибок, соблюдение стандартов и распространение знаний о кодовой базе.

**Контекст использования:** Проводится для каждого Pull/Merge Request. Ревьюеры изучают изменения, оставляют комментарии с предложениями по улучшению (comments), запрашивают правки (request changes) или одобряют слияние (approve).

**Пример:** В Pull Request на GitHub ревьюер осуществляет обратную связь создателю PR.
#### Checkstyle - Checkstyle

**Определение:** **Checkstyle** — это статический анализатор кода для Java, который проверяет исходный код на соответствие заданным стандартам оформления и правилам программирования. Он автоматически обнаруживает нарушения в стиле кода, такие как отступы, именование, размеры методов и классов, использование пробелов и скобок.

**Контекст использования:** Используется в процессе разработки и непрерывной интеграции (CI) для обеспечения единообразия кодовой базы команды и соблюдения соглашений по стилю (например, Google Java Style Guide, Sun Code Conventions). Интегрируется в IDE (как плагин), инструменты сборки (Maven, Gradle) и может быть запущен как отдельная утилита.

**Пример:**
Запуск: `./gradlew checkstyleMain` с целью проверки стиля кода.

### Вопрос 1: Различие между JDK, JRE и JVM

**Задача:** Объяснить, чем отличаются JDK, JRE и JVM на пальцах. Когда что ставить?

**Контекст:** В справке к проекту написано: "Для разработки нужен JDK, а на сервере — JRE". Непонятно, что именно устанавливать.

**Ограничения:** Читал определения в глоссарии, но общие фразы не помогают принять решение.

**Ожидаемый результат:** Чёткое правило: для какого сценария устанавливать какую компоненту.

**Критерии успеха:** Смогу правильно установить ПО для своей роли (разработчик/пользователь) и объяснить разницу коллеге.


### Вопрос 2: Механизм Pull Request (PR)

**Задача:** Понять конкретные шаги, из которых состоит PR. Что делать и в каком порядке?

**Контекст:** Теория ясна: "PR — это предложение изменений". Но на практике в GitHub теряюсь: какую ветку указать, куда нажать, что писать.

**Ограничения:** Создавал PR, но наугад. Не понимаю логики процесса.

**Ожидаемый результат:** Чек-лист из 5 ключевых шагов для создания правильного PR.

**Критерии успеха:** Смогу самостоятельно создать PR по инструкции и провести через него свою задачу.

## Технологический стек проекта

### Языки и платформы
- **Java 25 LTS** — основной язык разработки
- **Gradle 8.x** — система сборки (через Gradle Wrapper)

### Инструменты качества кода
- **Checkstyle** — статический анализ стиля кода
    - Конфигурация: `config/checkstyle/checkstyle.xml`
    - Запуск: `./gradlew checkstyleMain`
- **JUnit 5** — фреймворк тестирования
    - Запуск: `./gradlew test`

### CI/CD
- **GitHub Actions** — автоматическая проверка PR
    - Checkstyle на каждый коммит
    - Тесты на каждый коммит
    - Конфигурация: `.github/workflows/`

### Правила кода
- Стиль: Google Java Style Guide (через Checkstyle)
- Коммиты: Conventional Commits (`feat:`, `fix:`, `docs:`)
- Ветки: `feature/DVT-X` для задач, `master` — основная
- Pull Request: обязателен для слияния в master

